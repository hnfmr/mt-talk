\documentclass{beamer}
\usepackage{fancybox}
\usetheme{Rochester}
\usecolortheme{crane}
\title{Multithreading in C++11}
\subtitle{Threads, Sharing, Synchronisation and Memory model}
\author{Will Qi}
\date{20th June, 2012}

\begin{document}
\maketitle

\begin{frame}
  \frametitle{Outline}
  \begin{itemize}
  \item Threads
    \pause
  \item Sharing
    \pause
  \item Synchronisation
    \pause
  \item Memory model
  \end{itemize}
\end{frame}

%threads
\begin{frame}[fragile]
  \frametitle{Threads}
  \begin{block}{Launching}
\begin{verbatim}
class Worker {
  void run(std::vector<Object>& vec) { ... }
};
Worker worker;
std::vector<Object> vec;
std::thread t(&Worker::run, &worker, std::ref(vec));
\end{verbatim}
  \end{block}
  \pause
  \begin{block}{Joining/Detaching}
\begin{verbatim}
t.join(); t.detach();
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Threads}
  \begin{block}{Thread ID declaration}
\begin{verbatim}
std::thread::id main_thread_id;
\end{verbatim}
  \end{block}
  \pause
  \begin{block}{Comparison \& IO}
\begin{verbatim}
  if (std::this_thread::get_id() == main_thread_id) {
    ...
  }
  std::cout << std::this_thread::get_id() << std::endl;
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sharing}
  \begin{itemize}
  \item Mutal Exclusion
    \pause
    \begin{tabular}{l|l}
      \verb|std::mutex m;|&\\
      \hline
      \verb|{|&\\
      \hline
      \verb|  std::lock_guard lk(m);|&\verb|m.lock|\\
      \hline
      \verb|     ... work ...|&\\
      \hline
      \verb|}|&\verb|m.unlock()|:
    \end{tabular}\\
  \pause
  \item More locking utilities...
    Lock multiple mutexes using \verb|std::lock(Mutex& m1, Mutex& m2, ...)|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sharing}
Unique lock
\pause
\begin{itemize}
\item More flexible locking: deferred lock.
\begin{verbatim}
std::unique_lock lk(m, std::defer_lock);
\end{verbatim}
\pause
\item Movable locking, transfer lock ownership.
\begin{verbatim}
std::unique_lock<std::mutex> get_lock() {
  std::unique_lock<std::mutex> lk(some_mutex);
  prepare_data();
  return lk;
}

void process_data() {
  std::unique_lock<std::mutex> lk(get_lock());
  do_something();
}
\end{verbatim}
\end{itemize}
\end{frame}

% Synchronisation
\begin{frame}[fragile]
\frametitle{Condition Variable}
Sometimes we want to be notified of a condition, that is associated with an event, at just the right time, e.g. one thread attempts to prepare data:
\begin{verbatim}
std::mutex m;
std::condition_variable cond;
void prepare_data() {
  std::lock_guard<std::mutex> lk(m);
  queue->push(data);
  cond.notify_all();
}
\end{verbatim}
Other threads attempt to process data:
\begin{verbatim}
void process_data() {
  std::
}
\end{verbatim}
\end{frame}

%%%%%%%
\begin{frame}
  \frametitle{Threads}
  \begin{itemize}[<+->]
  \item<1> $abcadcabc$
  \item<1-2> \transboxout<2>{$abcabcabc$}
  \item<1-2> $accaccacc$
  \item<1> $bacbccbac$
  \item<1,3> $acdaccac$
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{theorem}<1->
    There exists an infinite set.
  \end{theorem}

  \begin{proof}<2->
    This follows from the axiom of infinity.
  \end{proof}
\end{frame}

%%%%
\begin{frame}[fragile]
  \frametitle{threads...}
  \begin{center}
    \begin{tabular}{l|c|c|c}
      &thread 1 & thread 2 & thread 3\\
      \hline
      1&\verb|m.lock()| & &\\
      \hline
      2&\verb|work|$\ldots$& & \verb|m.lock()|\\
      \hline
      3&\verb|more work|$\ldots$&&\\
      \hline
      4&m.unlock() &&\\
      \hline
      5&&&m.operation()
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{colums}
  \begin{columns}[t]
    \column{.33\textwidth}
    \begin{block}{\shadowbox{Sample Text}}
      ``What ever...''
    \end{block}
    \column{.33\textwidth}
    Thread 2

    \column{.33\textwidth}
    Thread 3
  \end{columns}
\end{frame}


\begin{frame}
  \begin{block}{\ovalbox{Introduction to {\LaTeX}}}
    ``Beamer is a {\LaTeX} class for creating presentations that re held
    using a projector...''
  \end{block}
\end{frame}
\end{document}
