\documentclass{beamer}
\usepackage{fancybox}
\usetheme{Rochester}
\usecolortheme{crane}
\title{Multithreading in C++11}
\subtitle{Threads, Sharing, Synchronisation and Memory model}
\author{Will Qi}
\date{20th June, 2012}

\begin{document}
\maketitle

\begin{frame}
  \frametitle{Outline}
  \begin{itemize}
  \item Threads
    \pause
  \item Sharing
    \pause
  \item Synchronisation
    \pause
  \item Memory model
  \end{itemize}
\end{frame}

%threads
\begin{frame}[fragile]
  \frametitle{Threads}
  \begin{block}{Launching}
\begin{verbatim}
class Worker {
  void run(std::vector<Object>& vec) { ... }
};
Worker worker;
std::vector<Object> vec;
std::thread t(&Worker::run, &worker, std::ref(vec));
\end{verbatim}
  \end{block}
  \pause
  \begin{block}{Joining/Detaching}
\begin{verbatim}
t.join(); t.detach();
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Threads - thread::id}
  \begin{block}{Thread ID declaration}
\begin{verbatim}
std::thread::id main_thread_id;
\end{verbatim}
  \end{block}
  \pause
  \begin{block}{Comparison \& IO}
\begin{verbatim}
  if (std::this_thread::get_id() == main_thread_id) {
    ...
  }
  std::cout << std::this_thread::get_id() << std::endl;
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sharing - Mutex and Lock Guard}
  \begin{itemize}
  \item Mutual Exclusion
    \pause
    \begin{tabular}{l|l}
      \verb|std::mutex m;|&\\
      \hline
      \verb|{|&\\
      \hline
      \verb|  std::lock_guard lk(m);|&\verb|m.lock|\\
      \hline
      \verb|     ... work ...|&\\
      \hline
      \verb|}|&\verb|m.unlock()|:
    \end{tabular}\\
    \pause
  \item More locking utilities...
    Lock multiple mutexes using \verb|std::lock(Mutex& m1, Mutex& m2, ...)|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sharing - Unique Lock}
  \pause
  \begin{itemize}
  \item More flexible lockings: \verb|std::deferred_lock|, \verb|std::adopt_lock|.
{\scriptsize
\begin{verbatim}
  std::unique_lock lk(m, std::defer_lock);
  std::unique_lock lk(m, std::adopt_lock);
\end{verbatim}
}
\pause
\item Movable lock, transfer lock ownership.
{\scriptsize
\begin{verbatim}
  std::unique_lock<std::mutex> get_lock() {
    std::unique_lock<std::mutex> lk(some_mutex);
    prepare_data();
    return lk;
  }

  void process_data() {
    std::unique_lock<std::mutex> lk(get_lock());
    do_something();
  }
\end{verbatim}
}
  \end{itemize}
\end{frame}

% Synchronisation
\begin{frame}[fragile]
  \frametitle{Synchronisation - Condition Variable}
\begin{itemize}
\item
  Sometimes we want to be notified of a condition, that is associated with an event, at just the right time, e.g. one thread attempts to prepare data:
  \pause
      {\scriptsize
\begin{verbatim}
  std::mutex m;
  std::condition_variable cond;
  void prepare_data() {
    std::lock_guard<std::mutex> lk(m);
    queue->push(data);
    cond.notify_all();
  }
\end{verbatim}
}
\pause
\item Other threads attempt to process data:
{\scriptsize
\begin{semiverbatim}
  void process_data() \{
    std::{\color{red}unique_lock}<std::mutex> lk(m);
    cond.wait(lk, []()->bool \{ return !queue->empty(); \});
  \}
\end{semiverbatim}
}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Synchronisation - Future}
Futures are used to communicate between threads.
\begin{itemize}
\item Lauching and waiting for a ``future''...
{\scriptsize
\begin{verbatim}
int some_long_running_task();

std::future<int> fut =
  std::async(std::launch::async | std::launch::deferred,
             some_long_running_task);
do_some_other_work();

auto result = fut.get();
\end{verbatim}
}
\item Other ways to launch a future:
{\scriptsize
\begin{verbatim}
auto f1 = std::async(&X::foo, &x, std::ref(arg));
auto f2 = std::async(&X::bar, x, "hello");
\end{verbatim}
}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Synchronisation - Packaged Task}
A packaged task associates a future to a function or callable object.
\begin{itemize}
\item Launch a packaged task.
{\scriptsize
\begin{verbatim}
int func() {
  return 5;
}
std::packaged_task<int()> task(func);
task();
\end{verbatim}
}
\item Or more elegantly:
{\scriptsize
\begin{verbatim}
auto task(std
\end{verbatim}
}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Synchronisation - Promise}
Promise
\begin{itemize}
\item a
\end{itemize}
\end{frame}
%%%%%%%
\begin{frame}
  \frametitle{Threads}
  \begin{itemize}[<+->]
  \item<1> $abcadcabc$
  \item<1-2> \transboxout<2>{$abcabcabc$}
  \item<1-2> $accaccacc$
  \item<1> $bacbccbac$
  \item<1,3> $acdaccac$
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{theorem}<1->
    There exists an infinite set.
  \end{theorem}

  \begin{proof}<2->
    This follows from the axiom of infinity.
  \end{proof}
\end{frame}

%%%%
\begin{frame}[fragile]
  \frametitle{threads...}
  \begin{center}
    \begin{tabular}{l|c|c|c}
      &thread 1 & thread 2 & thread 3\\
      \hline
      1&\verb|m.lock()| & &\\
      \hline
      2&\verb|work|$\ldots$& & \verb|m.lock()|\\
      \hline
      3&\verb|more work|$\ldots$&&\\
      \hline
      4&m.unlock() &&\\
      \hline
      5&&&m.operation()
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{colums}
  \begin{columns}[t]
    \column{.33\textwidth}
    \begin{block}{\shadowbox{Sample Text}}
      ``What ever...''
    \end{block}
    \column{.33\textwidth}
    Thread 2

    \column{.33\textwidth}
    Thread 3
  \end{columns}
\end{frame}


\begin{frame}
  \begin{block}{\ovalbox{Introduction to {\LaTeX}}}
    ``Beamer is a {\LaTeX} class for creating presentations that re held
    using a projector...''
  \end{block}
\end{frame}
\end{document}
